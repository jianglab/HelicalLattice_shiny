[{"name": "app.py", "content": "import numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport matplotlib.pyplot as plt\nimport shiny\nimport shinylive\nimport plotly\nimport plotly.express as px\nfrom shinywidgets import render_widget\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny.ui import div, HTML\n\nimport plotly.express as px\nfrom shinywidgets import render_plotly\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui\nfrom shiny.types import ImgData\nfrom shiny import session\n\nimport plotly.graph_objects as go\nfrom shinywidgets import output_widget, render_widget\n\nfrom urllib.parse import urlencode, parse_qs\nfrom shiny import reactive\n\n\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.accordion(\n                ui.accordion_panel(\n                    \"README\", \n                    ui.p(\"HelicalLattice is a Web app that helps the user to understand how a helical lattice and its underlying 2D lattice can interconvert. \"\n                         \"The user can specify any 2D lattice and choose a line segment connecting any pair of lattice points that defines the block of 2D lattice to be rolled up into a helical lattice.\"),\n                    value=\"readme_panel\",\n                    open=False\n                ),\n                id=\"sidebar_accordion\"\n            ),\n            ui.input_radio_buttons(\"radio\", \"\", [\"Helical\u21d22D\", \"2D\u21d2Helical\"]),\n            ui.output_ui(\"conditional_inputs\"), \n            ui.input_checkbox(\"share_url\", \"Show sharable URL\", value=False),\n            ui.markdown(\"*Developed by the [Jiang Lab@Purdue University](https://jiang.bio.purdue.edu). Report problems to Wen Jiang (jiang12 at purdue.edu)*\"),\n            id=\"sidebar_always\", open=\"always\"\n        ),\n        ui.row(\n            ui.column(12,  \n                ui.div(\n                    ui.h2(\"HelicalLattice: 2D Lattice \u21d4 Helical Lattice\"),\n                    style=\"text-align: center; margin-bottom: 20px;\"\n                )\n            ),\n            ui.column(4,\n                ui.div(\n                    style=\"text-align: center; margin-top: 20px;\"\n                ),\n            ),\n            ui.column(4, \n                ui.div(\n                    style=\"text-align: center; margin-top: 20px;\"\n                ),\n            ),\n            ui.column(4,\n                ui.div(\n                    style=\"text-align: center; margin-top: 20px;\"\n                ),\n            ),\n        ),\n        ui.output_ui(\"dynamic_plot\")  \n    )\n)\n    \n\ndef server(input, output, session):\n    @output\n    @render.text\n    def state_always():\n        return f\"testing here input.sidebar_always(): {input.sidebar_always()}\"\n\n    @reactive.Effect\n    @reactive.event(input.readme_btn)\n    def show_readme_info():\n        ui.notification_show(\"HelicalLattice is a Web app that helps the user to understand how a helical lattice and its underlying 2D lattice can interconvert. The user can specify any 2D lattice and choose a line segment connecting any pair of lattice points that defines the block of 2D lattice to be rolled up into a helical lattice\")\n\n    @output\n    @render.ui\n    def conditional_inputs():\n        if input.radio() == \"Helical\u21d22D\":\n            return ui.TagList(\n                ui.input_numeric('twist', 'Twist (\u00b0)', value=-81.1, min=-180., max=180., step=1.0),\n                ui.input_numeric('rise', 'Rise (\u00c5)', value=19.4, min=0.001, step=1.0),\n                ui.input_numeric('csym', 'Axial symmetry', value=1, min=1, step=1),\n                ui.input_numeric('diameter', 'Helical diameter (\u00c5)', value=290.0, min=0.1, step=1.0),\n                ui.input_numeric(\"length\", \"Helical length (\u00c5)\", value=1000.0, min=0.1, step=1.0),\n                ui.input_checkbox(\"primitive_unitcell\", \"Use primitive unit cell\", value=False),\n                ui.input_checkbox(\"horizontal\", \"Set unit cell vector a along x-axis\", value=True),\n                ui.input_numeric(\"lattice_size_factor\", \"2D lattice size factor\", value=1.25, min=1.0, step=0.1),\n                ui.input_numeric(\"marker_size\", \"Marker size (\u00c5)\", value=5.0, min=0.1, step=1.0),\n                ui.input_numeric(\"figure_height\", \"Plot height (pixels)\", value=800, min=1, step=10),\n            )\n        elif input.radio() == \"2D\u21d2Helical\":\n            return ui.TagList(\n                ui.input_numeric(\"ax\", \"Unit cell vector a.x (\u00c5)\", value=34.65, step=1.0),\n                ui.input_numeric(\"ay\", \"Unit cell vector a.y (\u00c5)\", value=0.0, step=1.0),\n                ui.input_numeric(\"bx\", \"Unit cell vector b.x (\u00c5)\", value=10.63, step=1.0),\n                ui.input_numeric(\"by\", \"Unit cell vector b.y (\u00c5)\", value=-23.01, step=1.0),\n                ui.input_numeric(\"na\", \"# units along unit cell vector a\", value=16, step=1),\n                ui.input_numeric(\"nb\", \"# units along unit cell vector b\", value=1, step=1),\n                ui.input_numeric(\"length\", \"Helical length (\u00c5)\", value=1000.0, min=0.1, step=1.0),\n                ui.input_numeric(\"lattice_size_factor\", \"2D lattice size factor\", value=1.25, min=1.0, step=0.1),\n                ui.input_numeric(\"marker_size\", \"Marker size (\u00c5)\", value=5.0, min=0.1, step=1.0),\n                ui.input_numeric(\"figure_height\", \"Plot height (pixels)\", value=800, min=1, step=10),\n            )\n\n    @output\n    @render.ui\n    def dynamic_plot():\n        if input.radio() == \"2D\u21d2Helical\":\n            col2 = ui.column(4,\n                ui.h3(\"2D Lattice: from which a block of area is selected to be rolled into a helix\"),\n                output_widget(\"plot_2d_2D_to_Helical\")\n            )\n            col3 = ui.column(4,\n                ui.h3(\"2D Lattice: selected area is ready to be rolled into a helix around the vertical axis\"),\n                output_widget(\"plot_helix_unrolled_2D_to_Helical\")\n            )\n            col4 = ui.column(4,\n                ui.h3(\"Helical Lattice: rolled up from the starting 2D lattice\"),\n                output_widget(\"plot_helix_2D_to_Helical\") \n            )\n        else:\n            col2 = ui.column(4,\n                ui.h3(\"Helical Lattice\"),\n                output_widget(\"plot_helix\")\n            )\n            col3 = ui.column(4,\n                ui.h3(\"Helical Lattice: unrolled into a 2D lattice\"),\n                output_widget(\"plot_helix_unrolled\")\n            )\n            col4 = ui.column(4,\n                ui.h3(\"2D Lattice: from which the helix was built\"),\n                output_widget(\"plot_2d\")\n            )\n\n        return ui.TagList(ui.row(col2, col3, col4))\n    \n    @output\n    @render_widget\n    def plot_helix():\n        diameter = input.diameter()\n        length = input.length()\n        twist = input.twist()\n        rise = input.rise()\n        csym = input.csym()\n        marker_size = input.marker_size()\n        figure_height = input.figure_height()\n        fig = plot_helical_lattice(diameter, length, twist, rise, csym, marker_size=marker_size*0.6, figure_height=figure_height)\n        return fig\n    \n    @output\n    @render_widget\n    def plot_helix_unrolled():\n        diameter = input.diameter()\n        length = input.length()\n        twist = input.twist()\n        rise = input.rise()\n        csym = input.csym()\n        marker_size = input.marker_size()\n        figure_height = input.figure_height()\n        fig = plot_helical_lattice_unrolled(diameter, length, twist, rise, csym, marker_size=marker_size, figure_height=figure_height)\n        return fig\n    \n    @output\n    @render_widget\n    def plot_2d():\n      a, b, endpoint = convert_helical_lattice_to_2d_lattice(\n          twist=input.twist(),\n          rise=input.rise(),\n          csym=input.csym(),\n          diameter=input.diameter(),\n          primitive_unitcell=input.primitive_unitcell(),\n          horizontal=input.horizontal()\n      )\n      length = input.length()\n      lattice_size_factor = input.lattice_size_factor()\n      marker_size = input.marker_size()\n      figure_height = input.figure_height()\n      fig = plot_2d_lattice(a, b, endpoint, length=length, lattice_size_factor=lattice_size_factor, marker_size=marker_size, figure_height=figure_height)\n      return fig\n    \n    @output\n    @render_widget\n    def plot_2d_2D_to_Helical():\n      na = input.na()\n      nb = input.nb()\n      ax = input.ax()\n      ay = input.ay()\n      bx = input.bx()\n      by = input.by()\n      a = (ax, ay)\n      b = (bx, by)\n      length = input.length()\n      lattice_size_factor = input.lattice_size_factor()\n      marker_size = input.marker_size()\n      figure_height = input.figure_height()\n      fig = plot_2d_lattice(a, b, endpoint=(na, nb), length=length, lattice_size_factor=lattice_size_factor, marker_size=marker_size, figure_height=figure_height)\n      return fig\n\n    @output\n    @render_widget\n    def plot_helix_unrolled_2D_to_Helical():\n      na = input.na()\n      nb = input.nb()  # Fixed: was input.na()\n      ax = input.ax()\n      ay = input.ay()\n      bx = input.bx()\n      by = input.by()\n      a = (ax, ay)\n      b = (bx, by)\n      twist2, rise2, csym2, diameter2 = convert_2d_lattice_to_helical_lattice(a=a, b=b, endpoint=(na, nb))\n\n      length = input.length()\n      marker_size = input.marker_size()\n      figure_height = input.figure_height()\n      fig = plot_helical_lattice_unrolled(diameter2, length, twist2, rise2, csym2, marker_size=marker_size, figure_height=figure_height)\n      return fig\n\n    @output\n    @render_widget\n    def plot_helix_2D_to_Helical():\n        na = input.na()\n        nb = input.nb()\n        ax = input.ax()\n        ay = input.ay()\n        bx = input.bx()\n        by = input.by()\n        a = (ax, ay)\n        b = (bx, by)\n        twist2, rise2, csym2, diameter2 = convert_2d_lattice_to_helical_lattice(a=a, b=b, endpoint=(na, nb))\n        length = input.length()\n        marker_size = input.marker_size()\n        figure_height = input.figure_height()\n        fig = plot_helical_lattice(diameter2, length, twist2, rise2, csym2, marker_size=marker_size*0.6, figure_height=figure_height)\n        return fig\n\n\n# Run the app\napp = App(app_ui, server)\n\nui.head_content(\n    ui.HTML(\n        \"\"\"\n        <!-- Global site tag (gtag.js) - Google Analytics -->\n        <script async src=\"https://www.googletagmanager.com/gtag/js?id=G-CTBKF6J4CG\"></script>\n        <script>\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){dataLayer.push(arguments);}\n          gtag('js', new Date());\n          gtag('config', 'G-CTBKF6J4CG');\n        </script>\n        \"\"\"\n    )\n)\n\nui.head_content(ui.tags.title(\"Helical Lattice\"))\n\n\ndef plot_2d_lattice(a=(1, 0), b=(0, 1), endpoint=(10, 0), length=10, lattice_size_factor=1.25, marker_size=10, figure_height=500):\n  a = np.array(a)\n  b = np.array(b)\n  na, nb = endpoint\n  v0 = na * a + nb * b\n  circumference = np.linalg.norm(v0)\n  v1 = np.array([-v0[1], v0[0]])\n  v1 = length * v1/np.linalg.norm(v1)\n  corner_points=[np.array([0, 0]), v0, v0+v1, v1]\n  x, y = zip(*(corner_points+[na*a]))\n  x0, x1 = min(x), max(x)\n  y0, y1 = min(y), max(y)\n  pad = min(x1-x0, y1-y0)*(lattice_size_factor-1)\n  xmin = x0 - pad\n  xmax = x1 + pad\n  ymin = y0 - pad\n  ymax = y1 + pad\n\n  nas = []\n  nbs = []\n  m = np.vstack((a, b)).T\n  for v in [(xmin, ymin), (xmin, ymax), (xmax, ymin), (xmax, ymax)]:\n    tmp_a, tmp_b = np.linalg.solve(m, v)\n    nas.append(tmp_a)\n    nbs.append(tmp_b)\n  na_min = np.floor(sorted(nas)[0])-2\n  na_max = np.floor(sorted(nas)[-1])+2\n  nb_min = np.floor(sorted(nbs)[0])-2\n  nb_max = np.floor(sorted(nbs)[-1])+2\n\n  ia = np.arange(na_min, na_max)\n  ib = np.arange(nb_min, nb_max)\n  x = []\n  y = []\n  for j in ib:\n    for i in ia:\n      v = i*a+j*b\n      if xmin <= v[0] <= xmax and ymin <= v[1] <= ymax:\n        x.append(v[0])\n        y.append(v[1])\n\n  import pandas as pd\n  import plotly.express as px\n  import plotly.graph_objects as go\n\n  df = pd.DataFrame({'x':x, 'y':y})\n  fig = px.scatter(df, x='x', y='y')\n\n  x, y = zip(*corner_points)\n  x = [*x, 0]\n  y = [*y, 0]\n  rectangle = go.Scatter(x=x, y=y, fill=\"toself\", mode='lines', line = dict(color='green', width=marker_size/5, dash='dash'))\n  fig.add_trace(rectangle)\n  \n  fig.data = (fig.data[1], fig.data[0])\n\n  arrow_start = [0, 0]\n  arrow_end = na*a\n  fig.add_annotation(\n    x=arrow_end[0],\n    y=arrow_end[1],\n    ax= arrow_start[0],\n    ay= arrow_start[1],\n    xref=\"x\",\n    yref=\"y\",\n    axref=\"x\",\n    ayref=\"y\",\n    showarrow=True,\n    arrowhead=2,  # type [1,8]\n    arrowsize=1,  # relative to arrowwidth\n    arrowwidth=3,   # pixel\n    arrowcolor=\"grey\",\n    opacity=1.0\n  )\n\n  arrow_start = na*a\n  arrow_end = v0\n  fig.add_annotation(\n    x=arrow_end[0],\n    y=arrow_end[1],\n    ax= arrow_start[0],\n    ay= arrow_start[1],\n    xref=\"x\",\n    yref=\"y\",\n    axref=\"x\",\n    ayref=\"y\",\n    showarrow=True,\n    arrowhead=2,  # type [1,8]\n    arrowsize=1,  # relative to arrowwidth\n    arrowwidth=3,   # pixel\n    arrowcolor=\"grey\",\n    opacity=1.0\n  )\n\n  arrow_start = [0, 0]\n  arrow_end = v0\n  fig.add_annotation(\n    x=arrow_end[0],\n    y=arrow_end[1],\n    ax= arrow_start[0],\n    ay= arrow_start[1],\n    xref=\"x\",\n    yref=\"y\",\n    axref=\"x\",\n    ayref=\"y\",\n    showarrow=True,\n    arrowhead=2,  # type [1,8]\n    arrowsize=1,  # relative to arrowwidth\n    arrowwidth=3,   # pixel\n    arrowcolor=\"red\",\n    opacity=1.0\n  )\n\n  fig.update_traces(marker_size=marker_size, showlegend=False)\n\n  fig.update_layout(\n    xaxis =dict(title='X (\u00c5)', range=[xmin, xmax], constrain='domain'),\n    yaxis =dict(title='Y (\u00c5)', range=[ymin, ymax], constrain='domain')\n  )\n  fig.update_yaxes(scaleanchor = \"x\", scaleratio = 1)\n\n  #title = \"$\\\\vec{a}=(\" + f\"{a[0]:.1f}, {a[1]:.1f})\u00c5\" + \"\\\\quad\\\\vec{b}=(\" +f\"{b[0]:.1f}, {b[1]:.1f})\u00c5\" + \"\\\\quad equator=(0,0) \\\\to\" + f\"{na}\" + \"\\\\vec{a}+\" +f\"{nb}\" + \"\\\\vec{b}$\"\n  title = f\"a=({a[0]:.2f}, {a[1]:.2f})\u00c5\\tb=({b[0]:.2f}, {b[1]:.2f})\u00c5<br>equator=(0,0)\u2192{na}*a{'+' if nb>=0 else ''}{nb}*b\\tcircumference={circumference:.2f}\"\n  fig.update_layout(title_text=title, title_x=0.5, title_xanchor=\"center\")\n  fig.update_layout(height=figure_height)\n  fig.update_layout(paper_bgcolor='rgba(0, 0, 0, 0)', plot_bgcolor='rgba(0, 0, 0, 0)')\n\n  return fig\n\ndef plot_helical_lattice_unrolled(diameter, length, twist, rise, csym, marker_size=10, figure_height=800):\n  circumference = np.pi*diameter\n  if rise>0:\n    n = min(int(length/2/rise)+2, 1000)\n    i = np.arange(-n, n+1)\n    xs = []\n    ys = []\n    syms = []\n    for si in range(csym):\n      x = np.fmod(twist * i + si/csym*360, 360)\n      x[x> 360] -= 360\n      x[x< 0] += 360\n      y = rise * i\n      xs.append(x)\n      ys.append(y)\n      syms.append(np.array([si]*len(x)))\n  x = np.concatenate(xs)\n  y = np.concatenate(ys)\n  sym = np.concatenate(syms)\n\n  import pandas as pd\n  df = pd.DataFrame({'x':x, 'y':y, 'csym':sym})\n  df[\"csym\"] = df[\"csym\"].astype(str)\n  \n  import plotly.express as px\n  import plotly.graph_objects as go\n  fig = px.scatter(df, x='x', y='y', color='csym' if csym>1 else None)\n\n  if twist>=0:\n    arrow_start = [0, 0]\n    arrow_end = [twist, rise]\n  else:\n    arrow_start = [360, 0]\n    arrow_end = [360+twist, rise]\n  fig.add_annotation(\n    x=arrow_end[0],\n    y=arrow_end[1],\n    ax= arrow_start[0],\n    ay= arrow_start[1],\n    xref=\"x\",\n    yref=\"y\",\n    axref=\"x\",\n    ayref=\"y\",\n    showarrow=True,\n    arrowhead=2,  # type [1,8]\n    arrowsize=1,  # relative to arrowwidth\n    arrowwidth=2,   # pixel\n    arrowcolor=\"red\",\n    opacity=1.0\n  )\n\n  i = np.arange(-n, n+1, 0.01)\n  for si in range(csym):\n    x = np.fmod(twist * i + si/csym*360, 360)\n    x[x> 360] -= 360\n    x[x< 0] += 360\n    y = rise * i\n    color = fig.data[si].marker.color\n    line = go.Scatter(x=x, y=y, mode ='lines', line = dict(color=color, width=marker_size/10, dash='dot'), opacity=1, showlegend=False)\n    fig.add_trace(line)\n  equator = go.Scatter(x=[0,360], y=[0,0], xaxis='x', line = dict(color='grey', width=marker_size/3, dash='dash'))\n  fig.add_trace(equator)\n  fig.update_traces(marker_size=marker_size, showlegend=False)\n\n  fig.update_yaxes(\n    scaleanchor = \"x\",\n    scaleratio = 360/circumference\n  )\n  fig.update_layout(\n    xaxis =dict(title='twist (\u00b0)', range=[0,360], tickvals=np.linspace(0,360,13), constrain='domain'),\n    yaxis =dict(title='rise (\u00c5)', range=[-length/2, length/2], constrain='domain'),\n  )\n  \n  title = f\"pitch={rise*abs(360/twist):.2f}\u00c5\\ttwist={twist:.2f}\u00b0 rise={rise:.2f}\u00c5 sym=c{csym}<br>diameter={diameter:.2f}\u00c5 circumference={circumference:.2f}\u00c5\"\n  fig.update_layout(title_text=title, title_x=0.5, title_xanchor=\"center\")\n  fig.update_layout(height=figure_height)\n  fig.update_layout(paper_bgcolor='rgba(0, 0, 0, 0)', plot_bgcolor='rgba(0, 0, 0, 0)')\n\n  return fig\n\ndef plot_helical_lattice(diameter, length, twist, rise, csym,  marker_size = 10, figure_height=500):\n  if rise>0:\n    n = min(int(length/2/rise)+2, 1000)\n    i = np.arange(-n, n+1)\n    xs = []\n    ys = []\n    zs = []\n    syms = []\n    for si in range(csym):\n      x = diameter/2 * np.cos(np.deg2rad(twist)*i+si/csym*2*np.pi)\n      y = diameter/2 * np.sin(np.deg2rad(twist)*i+si/csym*2*np.pi)\n      z = i * rise\n      xs.append(x)\n      ys.append(y)\n      zs.append(z)\n      syms.append(np.array([si]*len(z)))\n  x = np.concatenate(xs)\n  y = np.concatenate(ys)\n  z = np.concatenate(zs)\n  sym = np.concatenate(syms)\n\n  import pandas as pd\n  df = pd.DataFrame({'x':x, 'y':y, 'z':z, 'csym':sym})\n  df[\"csym\"] = df[\"csym\"].astype(str)\n  \n  import plotly.express as px\n  import plotly.graph_objects as go\n  fig = px.scatter_3d(df, x='x', y='y', z='z', labels={'x': 'X (\u00c5)', 'y':'Y (\u00c5)', 'z':'Z (\u00c5)'}, color='csym' if csym>1 else None)\n  fig.update_traces(marker_size = marker_size)\n\n  i = np.arange(-n, n+1, 5./(abs(twist)))\n  for si in range(csym):\n    x = diameter/2 * np.cos(np.deg2rad(twist)*i+si/csym*2*np.pi)\n    y = diameter/2 * np.sin(np.deg2rad(twist)*i+si/csym*2*np.pi)\n    z = i * rise\n    color = fig.data[si].marker.color\n    spiral = go.Scatter3d(x=x, y=y, z=z, mode ='lines', line = dict(color=color, width=marker_size/2), opacity=1, showlegend=False)\n    fig.add_trace(spiral)\n\n  def cylinder(r, h, z0=0, n_points=100, nv =50):\n    theta = np.linspace(0, 2*np.pi, n_points)\n    v = np.linspace(z0, z0+h, nv )\n    theta, v = np.meshgrid(theta, v)\n    x = r*np.cos(theta)\n    y = r*np.sin(theta)\n    z = v\n    return x, y, z\n  \n  def equator_circle(r, z, n_points=36):\n    theta = np.linspace(0, 2*np.pi, n_points)\n    x= r*np.cos(theta)\n    y = r*np.sin(theta)\n    z0 = z*np.ones(theta.shape)\n    return x, y, z0\n\n  x, y, z = cylinder(r=diameter/2-marker_size/2, h=length, z0=-length/2)\n  colorscale = [[0, 'white'], [1, 'white']]\n  cyl = go.Surface(x=x, y=y, z=z, colorscale = colorscale, showscale=False, opacity=0.8)\n  fig.add_trace(cyl)\n  x, y, z = equator_circle(r=diameter/2, z=0)\n  equator = go.Scatter3d(x=x, y=y, z=z, mode ='lines', line = dict(color='grey', width=marker_size/2, dash='dash'), opacity=1, showlegend=False)\n  fig.add_trace(equator)\n\n  title = f\"pitch={rise*abs(360/twist):.2f}\u00c5\\ttwist={twist:.2f}\u00b0 rise={rise:.2f}\u00c5 sym=c{csym}<br>diameter={diameter:.2f}\u00c5 circumference={np.pi*diameter:.2f}\u00c5\"\n  fig.update_layout(title_text=title, title_x=0.5, title_xanchor=\"center\")\n\n  camera = dict(\n    up=dict(x=0, y=0, z=1),\n    center=dict(x=0, y=0, z=0),\n    eye=dict(x=1, y=0, z=0)\n  )\n  fig.update_layout(scene_camera=camera)\n\n  fig.update_scenes(\n    xaxis =dict(range=[-diameter/2-marker_size, diameter/2+marker_size]),\n    yaxis =dict(range=[-diameter/2-marker_size, diameter/2+marker_size]),\n    zaxis =dict(range=[-length/2-marker_size, length/2+marker_size])\n  )\n\n  fig.update_scenes(xaxis_visible=False, yaxis_visible=False, zaxis_visible=False, camera_projection_type='orthographic', aspectmode='data')\n  fig.update_layout(height=figure_height)\n  fig.update_layout(paper_bgcolor='rgba(0, 0, 0, 0)')\n\n  return fig\n\ndef convert_2d_lattice_to_helical_lattice(a=(1, 0), b=(0, 1), endpoint=(10, 0)):\n  def set_to_periodic_range(v, min=-180, max=180):\n    from math import fmod\n    tmp = fmod(v-min, max-min)\n    if tmp>=0: tmp+=min\n    else: tmp+=max\n    return tmp\n  def length(v):\n    return np.linalg.norm(v)\n  def transform_vector(v, vref=(1, 0)):\n    ang = np.arctan2(vref[1], vref[0])\n    cos = np.cos(ang)\n    sin = np.sin(ang)\n    m = [[cos, sin], [-sin, cos]]\n    v2 = np.dot(m, v.T)\n    return v2\n  def on_equator(v, epsilon=0.5):\n      # test if b vector is on the equator\n      if abs(v[1]) > epsilon: return 0\n      return 1\n  \n  a, b, endpoint = map(np.array, (a, b, endpoint))\n  na, nb = endpoint\n  v_equator = na*a + nb*b\n  circumference = length(v_equator)\n  va = transform_vector(a, v_equator)\n  vb = transform_vector(b, v_equator)\n  minLength = max(1.0, min(np.linalg.norm(va), np.linalg.norm(vb)) * 0.9)\n  vs_on_equator = []\n  vs_off_equator = []\n  epsilon = 0.5\n  maxI = 10\n  for i in range(-maxI, maxI + 1):\n      for j in range(-maxI, maxI + 1):\n          if i or j:\n              v = i * va + j * vb\n              v[0] = set_to_periodic_range(v[0], min=0, max=circumference)\n              if np.linalg.norm(v) > minLength:\n                  if v[1]<0: v *= -1\n                  if on_equator(v, epsilon=epsilon):\n                      vs_on_equator.append(v)\n                  else:\n                      vs_off_equator.append(v)\n  twist, rise, csym = 0, 0, 1\n  if vs_on_equator:\n      vs_on_equator.sort(key=lambda v: abs(v[0]))\n      best_spacing = abs(vs_on_equator[0][0])\n      csym_f = circumference / best_spacing\n      expected_spacing = circumference/round(csym_f)\n      if abs(best_spacing - expected_spacing)/expected_spacing < 0.05:\n          csym = int(round(csym_f))\n  if vs_off_equator:\n      vs_off_equator.sort(key=lambda v: (abs(round(v[1]/epsilon)), abs(v[0])))\n      twist, rise = vs_off_equator[0]\n      twist *= 360/circumference\n      twist = set_to_periodic_range(twist, min=-360/(2*csym), max=360/(2*csym))\n  diameter = circumference/np.pi\n  return twist, rise, csym, diameter\n\ndef convert_helical_lattice_to_2d_lattice(twist=30, rise=20, csym=1, diameter=100, primitive_unitcell=False, horizontal=True):\n  def angle90(v1, v2):  # angle between two vectors, ignoring vector polarity [0, 90]\n      p = np.dot(v1, v2)/(np.linalg.norm(v1)*np.linalg.norm(v2))\n      p = np.clip(abs(p), 0, 1)\n      ret = np.rad2deg(np.arccos(p))  # 0<=angle<90\n      return ret\n  def transform_vector(v, vref=(1, 0)):\n    ang = np.arctan2(vref[1], vref[0])\n    cos = np.cos(ang)\n    sin = np.sin(ang)\n    m = [[cos, sin], [-sin, cos]]\n    v2 = np.dot(m, v.T)\n    return v2\n  \n  imax = int(5*360/abs(twist))\n  n = np.tile(np.arange(-imax, imax), reps=(2,1)).T\n  v = np.array([twist, rise], dtype=float) * n\n  if csym>1:\n    vs = []\n    for ci in range(csym):\n      tmp = v * 1.0\n      tmp[:, 0] += ci/csym * 360\n      vs.append(tmp)\n    v = np.vstack(vs)\n  v[:, 0] = np.fmod(v[:, 0], 360)\n  v[v[:, 0]<0, 0] += 360\n  v[:, 0] *= np.pi*diameter/360 # convert x-axis values from angles to distances\n  dist = np.linalg.norm(v, axis=1)\n  dist_indices = np.argsort(dist)\n\n  v = v[dist_indices] # now sorted from short to long distance\n  err = 1.0 # max angle between 2 vectors to consider non-parallel\n  vb = v[1]\n  for i in range(1, len(v)):\n    if angle90(vb, v[i])> err:\n      va = v[i]\n      break\n\n  ve = np.array([np.pi*diameter, 0])\n  m = np.vstack((va, vb)).T\n  na, nb = np.linalg.solve(m, ve)\n  endpoint = (round(na), round(nb))\n  \n  if not primitive_unitcell:\n    # find alternative unit cell vector pairs that has smallest angular difference to the helical equator\n    vabs = []\n    for ia in range(-1, 2):\n      for ib in range(-1, 2):\n        vabs.append(ia*va+ib*vb)\n    vabs_good = []\n    area = np.linalg.norm( np.cross(va, vb) )\n    for vai, vatmp in enumerate(vabs):\n      for vbi in range(vai+1, len(vabs)):\n        vbtmp = vabs[vbi]\n        areatmp = np.linalg.norm( np.cross(vatmp, vbtmp) )\n        if abs(areatmp-area)>err: continue\n        vabs_good.append( (vatmp, vbtmp) )\n    dist = []\n    for vi, (vatmp, vbtmp) in enumerate(vabs_good):\n        m = np.vstack((vatmp, vbtmp)).T\n        na, nb = np.linalg.solve(m, ve)\n        if abs(na-round(na))>1e-3: continue\n        if abs(nb-round(nb))>1e-3: continue\n        dist.append((abs(na)+abs(nb), -round(na), -round(nb), round(na), round(nb), vatmp, vbtmp))\n    if len(dist):\n      dist.sort(key=lambda x: x[:3])\n      na, nb, va, vb = dist[0][3:]\n      if np.linalg.norm(vb)>np.linalg.norm(va):\n        va, vb = vb, va\n        na, nb = nb, na\n      endpoint = (na, nb)\n\n  if va[0]<0:\n    va *= -1\n    vb *= -1\n    na *= -1\n    nb *= -1\n\n  if horizontal:\n    vb = transform_vector(vb, vref=va)\n    va = np.array([np.linalg.norm(va), 0.0])\n\n  return va, vb, endpoint\n\nif __name__ == \"__main__\":\n    shinylive.run(app)\n\n", "type": "text"}, {"name": "HelicalLattice.py", "content": "\"\"\" \nMIT License\n\nCopyright (c) 2022-2024 Wen Jiang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\"\"\"\ndef import_with_auto_install(packages, scope=locals()):\n    if isinstance(packages, str): packages=[packages]\n    for package in packages:\n        if package.find(\":\")!=-1:\n            package_import_name, package_pip_name = package.split(\":\")\n        else:\n            package_import_name, package_pip_name = package, package\n        try:\n            scope[package_import_name] = __import__(package_import_name)\n        except ImportError:\n            import subprocess\n            subprocess.call(f'pip install {package_pip_name}', shell=True)\n            scope[package_import_name] =  __import__(package_import_name)\nrequired_packages = \"streamlit numpy scipy pandas plotly\".split()\nimport_with_auto_install(required_packages)\"\"\"\n\nimport numpy as np\nimport pandas as pd\nimport plotly.graph_objects as go\nimport matplotlib.pyplot as plt\nimport shiny\nimport plotly\nimport plotly.express as px\nfrom shiny.express import input, render, ui\nfrom shinywidgets import render_widget\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny.ui import div, HTML\n\nimport plotly.express as px\nfrom shiny.express import input, render, ui\nfrom shinywidgets import render_plotly\n\ntips = px.data.tips()\n\nwith ui.layout_columns():\n    @render_plotly\n    def plot1():\n        p = px.hi\n        layout(height=200, xaxis_title=None)\n        return p\n\n    @render_plotly\n    def plot2():\n        p = px.histogram(tips, x=input.var2())\n        p.update_layout(height=200, xaxis_title=None)\n        return p\n\nwith ui.layout_columns():\n    ui.input_select(\"var1\", None, choices=[\"total_bill\", \"tip\"], width=\"100%\")\n    ui.input_select(\"var2\", None, choices=[\"tip\", \"total_bill\"], width=\"100%\")\n\n\"\"\"\ndef main():\n    title = \"HelicalLattice: 2D Lattice \u21d4 Helical Lattice\"\n    #st.set_page_config(page_title=title, layout=\"wide\")\n    ui.page_opts(title=title, fillable=True)\n    #st.title(title)\n\n    # st.elements.utils._shown_default_value_warning = True ## not converted\n\n    ## not converted\n    # if len(st.session_state)<1:  # only run once at the start of the session\n    #   set_session_state_from_query_params()\n    \n    col1 = st.sidebar\n\n    with col1:\n        with st.expander(label=\"README\", expanded=False):\n            st.write(\"**HelicalLattice** is a Web app that helps the user to understand how a helical lattice and its underlying 2D lattice can interconvert. The user can specify any 2D lattice and choose a line segment connecting any pair of lattice points that defines the block of 2D lattice to be rolled up into a helical lattice\")\n\n        direction = ui.input_radio_buttons(label=\"Mode:\", options=[\"Helical\u21d22D\", \"2D\u21d2Helical\"], index=0, label_visibility=\"collapsed\", horizontal=True, help=\"Choose a mode\", key=\"direction\")\n        if direction == \"2D\u21d2Helical\":\n            ax = ui.input_numeric('Unit cell vector a.x (\u00c5)', value=34.65, step=1.0, format=\"%.2f\", help=\"x coordinate of the unit cell a vector\", key=\"ax\")\n            ay = ui.input_numeric('Unit cell vector a.y (\u00c5)', value=0., step=1.0, format=\"%.2f\", help=\"y coordinate of the unit cell a vector\", key=\"ay\")\n            bx = ui.input_numeric('Unit cell vector b.x (\u00c5)', value=10.63, step=1.0, format=\"%.2f\", help=\"x coordinate of the unit cell b vector\", key=\"bx\")\n            by = ui.input_numeric('Unit cell vector b.y (\u00c5)', value=-23.01, step=1.0, format=\"%.2f\", help=\"y coordinate of the unit cell b vector\", key=\"by\")\n            na = ui.input_numeric('# units along unit cell vector a', value=16, step=1, format=\"%d\", help=\"# units along unit cell vector a\", key=\"na\")\n            nb = ui.input_numeric('# units along unit cell vector b', value=1, step=1, format=\"%d\", help=\"# units along unit cell vector b\", key=\"nb\")\n        else:\n            twist = ui.input_numeric('Twist (\u00b0)', value=-81.1, min_value=-180., max_value=180., step=1.0, format=\"%.2f\", help=\"twist\", key=\"twist\")\n            rise = ui.input_numeric('Rise (\u00c5)', value=19.4, min_value=0.001, step=1.0, format=\"%.2f\", help=\"rise\", key=\"rise\")\n            csym = ui.input_numeric('Axial symmetry', value=1, min_value=1, step=1, format=\"%d\", help=\"csym\", key=\"csym\")\n            diameter = ui.input_numeric('Helical diameter (\u00c5)', value=290.0, min_value=0.1, step=1.0, format=\"%.2f\", help=\"diameter of the helix\", key=\"diameter\")\n\n        length = ui.input_numeric('Helical length (\u00c5)', value=1000., min_value=0.1, step=1.0, format=\"%.2f\", help=\"length of the helix\", key=\"length\")\n\n        if direction == \"Helical\u21d22D\":\n            primitive_unitcell = ui.input_checkbox('Use primitive unit cell', value=False, help=\"Use primitive unit cell\", key=\"primitive_unitcell\")\n            horizontal = ui.input_checkbox('Set unit cell vector a along x-axis', value=True, help=\"Set unit cell vector a along x-axis\", key=\"horizontal\")\n            \n        lattice_size_factor = ui.input_checkbox('2D lattice size factor', value=1.25, min_value=1.0, step=0.1, format=\"%.2f\", help=\"Draw 2D lattice larger than the helix block by this factor\", key=\"lattice_size_factor\")\n        marker_size = ui.input_numeric('Marker size (\u00c5)', value=5., min_value=0.1, step=1.0, format=\"%.2f\", help=\"size of the markers\", key=\"marker_size\")\n        figure_height = ui.input_checkbox('Plot height (pixels)', value=800, min_value=1, step=10, format=\"%d\", help=\"height of plots\", key=\"figure_height\")\n\n        share_url = ui.input_checkbox('Show sharable URL', value=False, help=\"Include relevant parameters in the browser URL to allow you to share the URL and reproduce the plots\", key=\"share_url\")\n\n        ui.markdown(\"*Developed by the [Jiang Lab@Purdue University](https://jiang.bio.purdue.edu). Report problems to Wen Jiang (jiang12 at purdue.edu)*\")\n\n    if direction == \"2D\u21d2Helical\":\n        col2, col3, col4 = st.columns((1, 0.8, 0.7), gap=\"small\")\n  \n        a = (ax, ay)\n        b = (bx, by)\n        twist2, rise2, csym2, diameter2 = convert_2d_lattice_to_helical_lattice(a=a, b=b, endpoint=(na, nb))\n\n        with col2:\n            st.subheader(\"2D Lattice: from which a block of area is selected to be rolled into a helix\")\n            fig_2d = plot_2d_lattice(a, b, endpoint=(na, nb), length=length, lattice_size_factor=lattice_size_factor, marker_size=marker_size, figure_height=figure_height)\n            st.plotly_chart(fig_2d, use_container_width=True)\n\n        with col3:\n            st.subheader(\"2D Lattice: selected area is ready to be rolled into a helix around the vertical axis\")\n            fig_helix_unrolled = plot_helical_lattice_unrolled(diameter2, length, twist2, rise2, csym2, marker_size=marker_size, figure_height=figure_height)\n            st.plotly_chart(fig_helix_unrolled, use_container_width=True)\n\n        with col4:\n            st.subheader(\"Helical Lattice: rolled up from the starting 2D lattice \")\n            fig_helix = plot_helical_lattice(diameter2, length, twist2, rise2, csym2, marker_size=marker_size*0.6, figure_height=figure_height)\n            st.plotly_chart(fig_helix, use_container_width=True)\n    else:\n        col2, col3, col4 = st.columns((0.7, 0.8, 1), gap=\"small\")\n    \n        with col2:\n            st.subheader(\"Helical Lattice\")\n            fig_helix = plot_helical_lattice(diameter, length, twist, rise, csym, marker_size=marker_size*0.6, figure_height=figure_height)\n            st.plotly_chart(fig_helix, use_container_width=True)\n\n        with col3:\n            a, b, endpoint = convert_helical_lattice_to_2d_lattice(twist=twist, rise=rise, csym=csym, diameter=diameter,  primitive_unitcell=primitive_unitcell, horizontal=horizontal)\n\n            st.subheader(\"Helical Lattice: unrolled into a 2D lattice\")\n            fig_helix_unrolled = plot_helical_lattice_unrolled(diameter, length, twist, rise, csym, marker_size=marker_size, figure_height=figure_height)\n            st.plotly_chart(fig_helix_unrolled, use_container_width=True)\n\n        with col4:\n            st.subheader(\"2D Lattice: from which the helix was built\")\n            fig_2d = plot_2d_lattice(a, b, endpoint, length=length, lattice_size_factor=lattice_size_factor, marker_size=marker_size, figure_height=figure_height)\n            st.plotly_chart(fig_2d, use_container_width=True)\n\n    if share_url:\n        set_query_params_from_session_state()\n    else:\n        st.query_params.clear()\n\"\"\"\n\n\n\"\"\n\"\"\"\n\ndef plot_2d_lattice(a, b, endpoint, length, lattice_size_factor, marker_size, figure_height):\n    a = np.array(a)\n    b = np.array(b)\n    na, nb = endpoint\n    v0 = na * a + nb * b\n    circumference = np.linalg.norm(v0)\n    v1 = np.array([-v0[1], v0[0]])\n    v1 = length * v1/np.linalg.norm(v1)\n    corner_points = [np.array([0, 0]), v0, v0+v1, v1]\n    x, y = zip(*(corner_points+[na*a]))\n    x0, x1 = min(x), max(x)\n    y0, y1 = min(y), max(y)\n    pad = min(x1-x0, y1-y0)*(lattice_size_factor-1)\n    xmin = x0 - pad\n    xmax = x1 + pad\n    ymin = y0 - pad\n    ymax = y1 + pad\n\n    nas = []\n    nbs = []\n    m = np.vstack((a, b)).T\n    for v in [(xmin, ymin), (xmin, ymax), (xmax, ymin), (xmax, ymax)]:\n        tmp_a, tmp_b = np.linalg.solve(m, v)\n        nas.append(tmp_a)\n        nbs.append(tmp_b)\n    na_min = np.floor(sorted(nas)[0])-2\n    na_max = np.floor(sorted(nas)[-1])+2\n    nb_min = np.floor(sorted(nbs)[0])-2\n    nb_max = np.floor(sorted(nbs)[-1])+2\n\n    ia = np.arange(na_min, na_max)\n    ib = np.arange(nb_min, nb_max)\n    x = []\n    y = []\n    for j in ib:\n        for i in ia:\n            v = i*a+j*b\n            if xmin <= v[0] <= xmax and ymin <= v[1] <= ymax:\n                x.append(v[0])\n                y.append(v[1])\n\n    df = pd.DataFrame({'x': x, 'y': y})\n    fig = px.scatter(df, x='x', y='y')\n\n    x, y = zip(*corner_points)\n    x = [*x, 0]\n    y = [*y, 0]\n    rectangle = go.Scatter(x=x, y=y, fill=\"toself\", mode='lines', line=dict(color='green', width=marker_size/5, dash='dash'))\n    fig.add_trace(rectangle)\n  \n    fig.data = (fig.data[1], fig.data[0])\n\n    arrow_start = [0, 0]\n    arrow_end = na*a\n    fig.add_annotation(\n        x=arrow_end[0],\n        y=arrow_end[1],\n        ax=arrow_start[0],\n        ay=arrow_start[1],\n        xref=\"x\",\n        yref=\"y\",\n        axref=\"x\",\n        ayref=\"y\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=3,\n        arrowcolor=\"grey\",\n        opacity=1.0\n    )\n\n    arrow_start = na*a\n    arrow_end = v0\n    fig.add_annotation(\n        x=arrow_end[0],\n        y=arrow_end[1],\n        ax=arrow_start[0],\n        ay=arrow_start[1],\n        xref=\"x\",\n        yref=\"y\",\n        axref=\"x\",\n        ayref=\"y\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=3,\n        arrowcolor=\"grey\",\n        opacity=1.0\n    )\n\n    arrow_start = [0, 0]\n    arrow_end = v0\n    fig.add_annotation(\n        x=arrow_end[0],\n        y=arrow_end[1],\n        ax=arrow_start[0],\n        ay=arrow_start[1],\n        xref=\"x\",\n        yref=\"y\",\n        axref=\"x\",\n        ayref=\"y\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=3,\n        arrowcolor=\"red\",\n        opacity=1.0\n    )\n\n    fig.update_traces(marker_size=marker_size, showlegend=False)\n\n    fig.update_layout(\n        xaxis=dict(title='X (\u00c5)', range=[xmin, xmax], constrain='domain'),\n        yaxis=dict(title='Y (\u00c5)', range=[ymin, ymax], constrain='domain')\n    )\n    fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\n\n    title = f\"a=({a[0]:.2f}, {a[1]:.2f})\u00c5\\tb=({b[0]:.2f}, {b[1]:.2f})\u00c5<br>equator=(0,0)\u2192{na}*a{'+' if nb>=0 else ''}{nb}*b\\tcircumference={circumference:.2f}\"\n    fig.update_layout(title_text=title, title_x=0.5, title_xanchor=\"center\")\n    fig.update_layout(height=figure_height)\n    fig.update_layout(paper_bgcolor='rgba(0, 0, 0, 0)', plot_bgcolor='rgba(0, 0, 0, 0)')\n\n    return fig\n\ndef plot_helical_lattice_unrolled(diameter, length, twist, rise, csym, marker_size, figure_height):\n    circumference = np.pi * diameter\n    if rise > 0:\n        n = min(int(length/2/rise)+2, 1000)\n        i = np.arange(-n, n+1)\n        xs = []\n        ys = []\n        syms = []\n        for si in range(csym):\n            x = np.fmod(twist * i + si/csym * 360, 360)\n            x[x > 360] -= 360\n            x[x < 0] += 360\n            y = rise * i\n            xs.append(x)\n            ys.append(y)\n            syms.append(np.array([si] * len(x)))\n        x = np.concatenate(xs)\n        y = np.concatenate(ys)\n        sym = np.concatenate(syms)\n\n        df = pd.DataFrame({'x': x, 'y': y, 'csym': sym})\n        df[\"csym\"] = df[\"csym\"].astype(str)\n        \n        fig = px.scatter(df, x='x', y='y', color='csym' if csym > 1 else None)\n\n        if twist >= 0:\n            arrow_start = [0, 0]\n            arrow_end = [twist, rise]\n        else:\n            arrow_start = [360, 0]\n            arrow_end = [360 + twist, rise]\n        fig.add_annotation(\n            x=arrow_end[0],\n            y=arrow_end[1],\n            ax=arrow_start[0],\n            ay=arrow_start[1],\n            xref=\"x\",\n            yref=\"y\",\n            axref=\"x\",\n            ayref=\"y\",\n            showarrow=True,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor=\"red\",\n            opacity=1.0\n        )\n\n        i = np.arange(-n, n+1, 0.01)\n        for si in range(csym):\n            x = np.fmod(twist * i + si/csym * 360, 360)\n            x[x > 360] -= 360\n            x[x < 0] += 360\n            y = rise * i\n            color = fig.data[si].marker.color\n            line = go.Scatter(x=x, y=y, mode='lines', line=dict(color=color, width=marker_size/10, dash='dot'), opacity=1, showlegend=False)\n            fig.add_trace(line)\n        equator = go.Scatter(x=[0, 360], y=[0, 0], xaxis='x', line=dict(color='grey', width=marker_size/3, dash='dash'))\n        fig.add_trace(equator)\n        fig.update_traces(marker_size=marker_size, showlegend=False)\n\n        fig.update_yaxes(\n            scaleanchor=\"x\",\n            scaleratio=360 / circumference\n        )\n        fig.update_layout(\n            xaxis=dict(title='twist (\u00b0)', range=[0, 360], tickvals=np.linspace(0, 360, 13), constrain='domain'),\n            yaxis=dict(title='rise (\u00c5)', range=[-length/2, length/2], constrain='domain'),\n        )\n        \n        title = f\"pitch={rise * abs(360 / twist):.2f}\u00c5\\ttwist={twist:.2f}\u00b0 rise={rise:.2f}\u00c5\"\n        fig.update_layout(title_text=title, title_x=0.5, title_xanchor=\"center\")\n        fig.update_layout(height=figure_height)\n        fig.update_layout(paper_bgcolor='rgba(0, 0, 0, 0)', plot_bgcolor='rgba(0, 0, 0, 0)')\n    else:\n        fig = go.Figure()\n    return fig\n\ndef plot_helical_lattice(diameter, length, twist, rise, csym, marker_size=10, figure_height=500):\n    if rise > 0:\n        n = min(int(length/2/rise)+2, 1000)\n        i = np.arange(-n, n+1)\n        xs = []\n        ys = []\n        zs = []\n        syms = []\n        for si in range(csym):\n            x = diameter/2 * np.cos(np.deg2rad(twist)*i + si/csym*2*np.pi)\n            y = diameter/2 * np.sin(np.deg2rad(twist)*i + si/csym*2*np.pi)\n            z = i * rise\n            xs.append(x)\n            ys.append(y)\n            zs.append(z)\n            syms.append(np.array([si]*len(z)))\n        x = np.concatenate(xs)\n        y = np.concatenate(ys)\n        z = np.concatenate(zs)\n        sym = np.concatenate(syms)\n\n        df = pd.DataFrame({'x': x, 'y': y, 'z': z, 'csym': sym})\n        df[\"csym\"] = df[\"csym\"].astype(str)\n        \n        fig = px.scatter_3d(df, x='x', y='y', z='z', labels={'x': 'X (\u00c5)', 'y': 'Y (\u00c5)', 'z': 'Z (\u00c5)'}, color='csym' if csym > 1 else None)\n        fig.update_traces(marker_size=marker_size)\n\n        i = np.arange(-n, n+1, 5./(abs(twist)))\n        for si in range(csym):\n            x = diameter/2 * np.cos(np.deg2rad(twist)*i + si/csym*2*np.pi)\n            y = diameter/2 * np.sin(np.deg2rad(twist)*i + si/csym*2*np.pi)\n            z = i * rise\n            color = fig.data[si].marker.color\n            spiral = go.Scatter3d(x=x, y=y, z=z, mode='lines', line=dict(color=color, width=marker_size/2), opacity=1, showlegend=False)\n            fig.add_trace(spiral)\n\n        def cylinder(r, h, z0=0, n_points=100, nv=50):\n            theta = np.linspace(0, 2*np.pi, n_points)\n            v = np.linspace(z0, z0+h, nv)\n            theta, v = np.meshgrid(theta, v)\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            z = v\n            return x, y, z\n        \n        def equator_circle(r, z, n_points=36):\n            theta = np.linspace(0, 2*np.pi, n_points)\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            z0 = z * np.ones(theta.shape)\n            return x, y, z0\n\n        x, y, z = cylinder(r=diameter/2 - marker_size/2, h=length, z0=-length/2)\n        colorscale = [[0, 'white'], [1, 'white']]\n        cyl = go.Surface(x=x, y=y, z=z, colorscale=colorscale, showscale=False, opacity=0.8)\n        fig.add_trace(cyl)\n        x, y, z = equator_circle(r=diameter/2, z=0)\n        equator = go.Scatter3d(x=x, y=y, z=z, mode='lines', line=dict(color='grey', width=marker_size/2, dash='dash'), opacity=1, showlegend=False)\n        fig.add_trace(equator)\n\n        title = f\"pitch={rise*abs(360/twist):.2f}\u00c5\\ttwist={twist:.2f}\u00b0 rise={rise:.2f}\u00c5 sym=c{csym}<br>diameter={diameter:.2f}\u00c5 circumference={np.pi*diameter:.2f}\u00c5\"\n        fig.update_layout(title_text=title, title_x=0.5, title_xanchor=\"center\")\n\n        camera = dict(\n            up=dict(x=0, y=0, z=1),\n            center=dict(x=0, y=0, z=0),\n            eye=dict(x=1, y=0, z=0)\n        )\n        fig.update_layout(scene_camera=camera)\n\n        fig.update_scenes(\n            xaxis=dict(range=[-diameter/2 - marker_size, diameter/2 + marker_size]),\n            yaxis=dict(range=[-diameter/2 - marker_size, diameter/2 + marker_size]),\n            zaxis=dict(range=[-length/2 - marker_size, length/2 + marker_size])\n        )\n\n        fig.update_scenes(xaxis_visible=False, yaxis_visible=False, zaxis_visible=False, camera_projection_type='orthographic', aspectmode='data')\n        fig.update_layout(height=figure_height)\n        fig.update_layout(paper_bgcolor='rgba(0, 0, 0, 0)')\n\n        return fig\n    else:\n        fig = go.Figure()\n        return fig\n\ndef convert_2d_lattice_to_helical_lattice(a=(1, 0), b=(0, 1), endpoint=(10, 0)):\n  def set_to_periodic_range(v, min=-180, max=180):\n    from math import fmod\n    tmp = fmod(v-min, max-min)\n    if tmp>=0: tmp+=min\n    else: tmp+=max\n    return tmp\n  def length(v):\n    return np.linalg.norm(v)\n  def transform_vector(v, vref=(1, 0)):\n    ang = np.arctan2(vref[1], vref[0])\n    cos = np.cos(ang)\n    sin = np.sin(ang)\n    m = [[cos, sin], [-sin, cos]]\n    v2 = np.dot(m, v.T)\n    return v2\n  def on_equator(v, epsilon=0.5):\n      # test if b vector is on the equator\n      if abs(v[1]) > epsilon: return 0\n      return 1\n  \n  a, b, endpoint = map(np.array, (a, b, endpoint))\n  na, nb = endpoint\n  v_equator = na*a + nb*b\n  circumference = length(v_equator)\n  va = transform_vector(a, v_equator)\n  vb = transform_vector(b, v_equator)\n  minLength = max(1.0, min(np.linalg.norm(va), np.linalg.norm(vb)) * 0.9)\n  vs_on_equator = []\n  vs_off_equator = []\n  epsilon = 0.5\n  maxI = 10\n  for i in range(-maxI, maxI + 1):\n      for j in range(-maxI, maxI + 1):\n          if i or j:\n              v = i * va + j * vb\n              v[0] = set_to_periodic_range(v[0], min=0, max=circumference)\n              if np.linalg.norm(v) > minLength:\n                  if v[1]<0: v *= -1\n                  if on_equator(v, epsilon=epsilon):\n                      vs_on_equator.append(v)\n                  else:\n                      vs_off_equator.append(v)\n  twist, rise, csym = 0, 0, 1\n  if vs_on_equator:\n      vs_on_equator.sort(key=lambda v: abs(v[0]))\n      best_spacing = abs(vs_on_equator[0][0])\n      csym_f = circumference / best_spacing\n      expected_spacing = circumference/round(csym_f)\n      if abs(best_spacing - expected_spacing)/expected_spacing < 0.05:\n          csym = int(round(csym_f))\n  if vs_off_equator:\n      vs_off_equator.sort(key=lambda v: (abs(round(v[1]/epsilon)), abs(v[0])))\n      twist, rise = vs_off_equator[0]\n      twist *= 360/circumference\n      twist = set_to_periodic_range(twist, min=-360/(2*csym), max=360/(2*csym))\n  diameter = circumference/np.pi\n  return twist, rise, csym, diameter\n\ndef convert_helical_lattice_to_2d_lattice(twist=30, rise=20, csym=1, diameter=100, primitive_unitcell=False, horizontal=True):\n    def angle90(v1, v2):  # angle between two vectors, ignoring vector polarity [0, 90]\n        p = np.dot(v1, v2)/(np.linalg.norm(v1)*np.linalg.norm(v2))\n        p = np.clip(abs(p), 0, 1)\n        ret = np.rad2deg(np.arccos(p))  # 0<=angle<90\n        return ret\n\n    def transform_vector(v, vref=(1, 0)):\n        ang = np.arctan2(vref[1], vref[0])\n        cos = np.cos(ang)\n        sin = np.sin(ang)\n        m = [[cos, sin], [-sin, cos]]\n        v2 = np.dot(m, v.T)\n        return v2\n\n    imax = int(5 * 360 / abs(twist))\n    n = np.tile(np.arange(-imax, imax), reps=(2, 1)).T\n    v = np.array([twist, rise], dtype=float) * n\n    if csym > 1:\n        vs = []\n        for ci in range(csym):\n            tmp = v * 1.0\n            tmp[:, 0] += ci / csym * 360\n            vs.append(tmp)\n        v = np.vstack(vs)\n    v[:, 0] = np.fmod(v[:, 0], 360)\n    v[v[:, 0] < 0, 0] += 360\n    v[:, 0] *= np.pi * diameter / 360  # convert x-axis values from angles to distances\n    dist = np.linalg.norm(v, axis=1)\n    dist_indices = np.argsort(dist)\n\n    v = v[dist_indices]  # now sorted from short to long distance\n    err = 1.0  # max angle between 2 vectors to consider non-parallel\n    vb = v[1]\n    for i in range(1, len(v)):\n        if angle90(vb, v[i]) > err:\n            va = v[i]\n            break\n\n    ve = np.array([np.pi * diameter, 0])\n    m = np.vstack((va, vb)).T\n    na, nb = np.linalg.solve(m, ve)\n    endpoint = (round(na), round(nb))\n\n    if not primitive_unitcell:\n        vabs = []\n        for ia in range(-1, 2):\n            for ib in range(-1, 2):\n                vabs.append(ia * va + ib * vb)\n        vabs_good = []\n        area = np.linalg.norm(np.cross(va, vb))\n        for vai, vatmp in enumerate(vabs):\n            for vbi in range(vai + 1, len(vabs)):\n                vbtmp = vabs[vbi]\n                areatmp = np.linalg.norm(np.cross(vatmp, vbtmp))\n                if abs(areatmp - area) > err:\n                    continue\n                vabs_good.append((vatmp, vbtmp))\n        dist = []\n        for vi, (vatmp, vbtmp) in enumerate(vabs_good):\n            m = np.vstack((vatmp, vbtmp)).T\n            na, nb = np.linalg.solve(m, ve)\n            if abs(na - round(na)) > 1e-3:\n                continue\n            if abs(nb - round(nb)) > 1e-3:\n                continue\n            dist.append((abs(na) + abs(nb), -round(na), -round(nb), round(na), round(nb), vatmp, vbtmp))\n        if len(dist):\n            dist.sort(key=lambda x: x[:3])\n            na, nb, va, vb = dist[0][3:]\n            if np.linalg.norm(vb) > np.linalg.norm(va):\n                va, vb = vb, va\n                na, nb = nb, na\n            endpoint = (na, nb)\n\n    if va[0] < 0:\n        va *= -1\n        vb *= -1\n        na *= -1\n        nb *= -1\n\n    if horizontal:\n        vb = transform_vector(vb, vref=va)\n        va = np.array([np.linalg.norm(va), 0.0])\n\n    return va, vb, endpoint\n\n\n\nint_types = {'csym':1, 'figure_height':800, 'horizontal':1, 'na':16, 'nb':1, 'primitive_unitcell':0, 'share_url':0}\nfloat_types = {'ax':34.65, 'ay':0.0, 'bx':10.63, 'by':-23.01, 'diameter':290.0, 'lattice_size_factor':1.25, 'length':1000.0, 'marker_size':5.0, 'rise':19.4, 'twist':-81.1}\ndefault_values = int_types | float_types | {'direction':'Helical\u21d22D', }\ndef set_initial_session_state():\n    global session_state\n    session_state = shiny.reactiveValues()\n    for attr in sorted(default_values.keys()):\n        if attr in int_types:\n            setattr(session_state, attr, int(default_values[attr]))\n        elif attr in float_types:\n            setattr(session_state, attr, float(default_values[attr]))\n        else:\n            setattr(session_state, attr, default_values[attr])\n\n\ndef set_query_params_from_session_state():\n    global session_state\n    # Create a dictionary to hold query parameters\n    params = {}\n    \n    # Filter and prepare the parameters based on session state\n    for attr in sorted(default_values.keys()):\n        v = getattr(session_state, attr)\n        if session_state.direction == '2D\u21d2Helical':\n            if attr in ['twist', 'rise', 'csym']:\n                continue\n        else:\n            if attr in ['ax', 'ay', 'bx', 'by', 'na', 'nb']:\n                continue\n        \n        if v == default_values[attr]:\n            continue\n        \n        if attr in int_types or isinstance(v, bool):\n            params[attr] = int(v)\n        elif attr in float_types:\n            params[attr] = f'{float(v):g}'\n        else:\n            params[attr] = v\n\ndef set_session_state_from_query_params():\n    # Retrieve query parameters from URL\n    query_params = shiny.get_query_parameters()\n    \n    # Update session state based on query parameters\n    for attr in sorted(query_params.keys()):\n        v = query_params[attr]\n        if attr in int_types:\n            setattr(session_state, attr, int(v))\n        elif attr in float_types:\n            setattr(session_state, attr, float(v))\n        else:\n            setattr(session_state, attr, v)\n\ndef setup_anonymous_usage_tracking():\n    try:\n        import pathlib, stat\n        index_file = pathlib.Path(st.__file__).parent / \"static/index.html\"\n        index_file.chmod(stat.S_IRUSR|stat.S_IWUSR|stat.S_IRGRP|stat.S_IROTH)\n        txt = index_file.read_text()\n        if txt.find(\"gtag/js?\")==-1:\n            txt = txt.replace(\"<head>\", '''<head><script async src=\"https://www.googletagmanager.com/gtag/js?id=G-CTBKF6J4CG\"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-CTBKF6J4CG');</script>''')\n            index_file.write_text(txt)\n    except:\n        pass\n\"\"\"\n\"\"\n\"\"\"if __name__ == \"__main__\":\n  import importlib\n  if importlib.util.find_spec(\"pyodide\") is None:\n    setup_anonymous_usage_tracking()\n  main()\"\"\"", "type": "text"}, {"name": "Testing.py", "content": "import matplotlib.pyplot as plt\nimport numpy as np\nimport plotly.express as px\nfrom shiny.express import input, render, ui\nfrom shinywidgets import render_plotly\nfrom shiny import App, Inputs, Outputs, Session, render, ui\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_slider(\"n\", \"N\", min=0, max=100, value=20),\n    ),\n    ui.card(\n        ui.output_plot(\"plot\"),\n    ),\n)\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    @render.plot(alt=\"A histogram\")\n    def plot() -> object:\n        np.random.seed(19680801)\n        x = 100 + 15 * np.random.randn(437)\n\n        fig, ax = plt.subplots()\n        ax.hist(x, input.n(), density=True)\n        return fig\n\n\napp = App(app_ui, server)\n\n", "type": "text"}, {"name": "requirements.txt", "content": "palmerpenguins", "type": "text"}]